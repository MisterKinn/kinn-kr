"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/converter/page",{

/***/ "(app-pages-browser)/./src/app/converter/converter.js":
/*!****************************************!*\
  !*** ./src/app/converter/converter.js ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateExchangeRate: function() { return /* binding */ calculateExchangeRate; },\n/* harmony export */   convertCurrency: function() { return /* binding */ convertCurrency; },\n/* harmony export */   displayErrorMessage: function() { return /* binding */ displayErrorMessage; },\n/* harmony export */   exchangeRates: function() { return /* binding */ exchangeRates; },\n/* harmony export */   getUserCountry: function() { return /* binding */ getUserCountry; },\n/* harmony export */   lastUpdateTime: function() { return /* binding */ lastUpdateTime; },\n/* harmony export */   mapCountryCode: function() { return /* binding */ mapCountryCode; },\n/* harmony export */   updateExchangeRates: function() { return /* binding */ updateExchangeRates; }\n/* harmony export */ });\nlet exchangeRates = {};\nlet lastUpdateTime = null;\nfunction displayErrorMessage(message) {\n    console.error(message);\n    alert(message);\n}\nfunction displayLastUpdateTime() {\n    const updateElement = document.querySelector(\"#lastUpdateTime\");\n    if (lastUpdateTime) {\n        const formattedTime = new Date(lastUpdateTime).toLocaleString();\n        updateElement.textContent = \"Last Updated: \".concat(formattedTime);\n    } else {\n        updateElement.textContent = \"Data has not been updated yet.\";\n    }\n}\nasync function updateExchangeRates() {\n    try {\n        const response = await fetch(\"https://api.exchangerate-api.com/v4/latest/USD\" // Fetch Exchange Rates\n        );\n        const data = await response.json();\n        if (data.rates) {\n            // Filter desired currencies from the API response\n            const desiredCurrencies = [\n                \"USD\",\n                \"KRW\",\n                \"AUD\",\n                \"BRL\",\n                \"CAD\",\n                \"CNY\",\n                \"EUR\",\n                \"GBP\",\n                \"JPY\",\n                \"MXN\",\n                \"PHP\"\n            ];\n            const filteredRates = Object.fromEntries(Object.entries(data.rates).filter((param)=>{\n                let [currency] = param;\n                return desiredCurrencies.includes(currency);\n            }));\n            exchangeRates = filteredRates;\n            lastUpdateTime = Date.now();\n            console.log(\"Exchange Rates Updated:\", exchangeRates);\n            displayLastUpdateTime();\n        } else {\n            console.error(\"Failed to update Exchange Rates:\", data);\n        }\n    } catch (error) {\n        console.error(\"Error updating Exchange Rates:\", error);\n    }\n}\nfunction mapCountryCode(apiCountryCode) {\n    const codeMapping = {\n        US: \"usd\",\n        KR: \"krw\",\n        AU: \"aud\",\n        BR: \"brl\",\n        CA: \"cad\",\n        CN: \"cny\",\n        EU: \"eur\",\n        GB: \"gbp\",\n        JP: \"jpy\",\n        MX: \"mxn\",\n        PH: \"php\"\n    };\n    return codeMapping[apiCountryCode] || apiCountryCode;\n}\nasync function getUserCountry() {\n    try {\n        const response = await fetch(\"https://ipapi.co/json/\");\n        const data = await response.json();\n        if (data.country) {\n            return mapCountryCode(document.querySelector(\"#fromCurrency\").value);\n        } else {\n            console.error(\"Failed to get user country:\", data);\n            return null;\n        }\n    } catch (error) {\n        console.error(\"Error getting user country:\", error);\n        return null;\n    }\n}\nasync function initialize() {\n    const defaultCurrency = \"\";\n    if (defaultCurrency) {\n        const fromCurrencyElement = document.querySelector(\"#fromCurrency\");\n        const toCurrencyElement = document.querySelector(\"#toCurrency\");\n        fromCurrencyElement.value = defaultCurrency;\n        toCurrencyElement.value = \"usd\";\n        await updateExchangeRates();\n        displayLastUpdateTime();\n        setInterval(updateExchangeRates, 3600000); // Update Exchange Rates every 1 hr\n    } else {\n        console.error(\"Failed to get user country code. Please set default currency manually.\");\n    }\n}\nif (true) {\n    window.addEventListener(\"load\", initialize);\n}\nfunction calculateExchangeRate(fromCurrency, toCurrency) {\n    if (exchangeRates && exchangeRates[fromCurrency] && exchangeRates[toCurrency]) {\n        return exchangeRates[toCurrency] / exchangeRates[fromCurrency];\n    }\n    return null;\n}\nasync function convertCurrency(fromCurrency, toCurrency, amount) {\n    const fromCurrencyElement = document.querySelector(\"#fromCurrency\");\n    const toCurrencyElement = document.querySelector(\"#toCurrency\");\n    const amountElement = document.querySelector(\"#amount\");\n    if (!fromCurrencyElement || !toCurrencyElement || !amountElement) {\n        console.error(\"Required elements not found. Please check your HTML structure.\");\n        return;\n    }\n    fromCurrency = String(fromCurrency).toUpperCase();\n    toCurrency = String(toCurrency).toUpperCase();\n    amount = parseFloat(amount);\n    if (!amount) {\n        // No amount\n        return;\n    }\n    try {\n        if (Object.keys(exchangeRates).length === 0) {\n            await updateExchangeRates();\n        }\n        const exchangeRate = calculateExchangeRate(fromCurrency, toCurrency);\n        if (exchangeRate === null) {\n            return;\n        }\n        const result = (amount * exchangeRate).toFixed(2);\n        const formattedFromCurrency = new Intl.NumberFormat(\"en-US\", {\n            style: \"currency\",\n            currency: fromCurrency,\n            minimumFractionDigits: 2,\n            maximumFractionDigits: 2,\n            currencyDisplay: \"symbol\"\n        }).format(amount.toFixed(2));\n        const formattedToCurrency = new Intl.NumberFormat(\"en-US\", {\n            style: \"currency\",\n            currency: toCurrency,\n            minimumFractionDigits: 2,\n            maximumFractionDigits: 2,\n            currencyDisplay: \"symbol\"\n        }).format(result);\n        const resultElement = document.querySelector(\"#result\");\n        if (!resultElement) {\n            console.error(\"Result element not found. Please check your HTML structure.\");\n            return;\n        }\n        resultElement.innerHTML = \"\".concat(formattedFromCurrency, \" = \").concat(formattedToCurrency);\n        const lastUpdatedElement = document.querySelector(\"#lastUpdated\");\n        if (lastUpdatedElement) {\n            lastUpdatedElement.textContent = \"Last Updated: \".concat(new Date().toLocaleString());\n        }\n    } catch (error) {\n        console.error(\"Error converting currency:\", error);\n        displayErrorMessage(\"Error converting currency.\");\n    }\n}\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvY29udmVydGVyL2NvbnZlcnRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLElBQUlBLGdCQUFnQixDQUFDO0FBQ3JCLElBQUlDLGlCQUFpQjtBQUVyQixTQUFTQyxvQkFBb0JDLE9BQU87SUFDaENDLFFBQVFDLEtBQUssQ0FBQ0Y7SUFDZEcsTUFBTUg7QUFDVjtBQUVBLFNBQVNJO0lBQ0wsTUFBTUMsZ0JBQWdCQyxTQUFTQyxhQUFhLENBQUM7SUFFN0MsSUFBSVQsZ0JBQWdCO1FBQ2hCLE1BQU1VLGdCQUFnQixJQUFJQyxLQUFLWCxnQkFBZ0JZLGNBQWM7UUFDN0RMLGNBQWNNLFdBQVcsR0FBRyxpQkFBK0IsT0FBZEg7SUFDakQsT0FBTztRQUNISCxjQUFjTSxXQUFXLEdBQUc7SUFDaEM7QUFDSjtBQUVBLGVBQWVDO0lBQ1gsSUFBSTtRQUNBLE1BQU1DLFdBQVcsTUFBTUMsTUFDbkIsaURBQWlELHVCQUF1Qjs7UUFFNUUsTUFBTUMsT0FBTyxNQUFNRixTQUFTRyxJQUFJO1FBRWhDLElBQUlELEtBQUtFLEtBQUssRUFBRTtZQUNaLGtEQUFrRDtZQUNsRCxNQUFNQyxvQkFBb0I7Z0JBQ3RCO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2FBQ0g7WUFDRCxNQUFNQyxnQkFBZ0JDLE9BQU9DLFdBQVcsQ0FDcENELE9BQU9FLE9BQU8sQ0FBQ1AsS0FBS0UsS0FBSyxFQUFFTSxNQUFNLENBQUM7b0JBQUMsQ0FBQ0MsU0FBUzt1QkFDekNOLGtCQUFrQk8sUUFBUSxDQUFDRDs7WUFJbkMzQixnQkFBZ0JzQjtZQUNoQnJCLGlCQUFpQlcsS0FBS2lCLEdBQUc7WUFDekJ6QixRQUFRMEIsR0FBRyxDQUFDLDJCQUEyQjlCO1lBQ3ZDTztRQUNKLE9BQU87WUFDSEgsUUFBUUMsS0FBSyxDQUFDLG9DQUFvQ2E7UUFDdEQ7SUFDSixFQUFFLE9BQU9iLE9B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QyxTQUFTO1lBQ3ZEQyxPQUFPO1lBQ1A3QyxVQUFVOEI7WUFDVmdCLHVCQUF1QjtZQUN2QkMsdUJBQXVCO1lBQ3ZCQyxpQkFBaUI7UUFDckIsR0FBR0MsTUFBTSxDQUFDVDtRQUVWLE1BQU1XLGdCQUFnQnJFLFNBQVNDLGFBQWEsQ0FBQztRQUU3QyxJQUFJLENBQUNvRSxlQUFlO1lBQ2hCMUUsUUFBUUMsS0FBSyxDQUNUO1lBRUo7UUFDSjtRQUVBeUUsY0FBY0MsU0FBUyxHQUFHLEdBQThCRixPQUEzQlIsdUJBQXNCLE9BQXlCLE9BQXBCUTtRQUV4RCxNQUFNRyxxQkFBcUJ2RSxTQUFTQyxhQUFhLENBQUM7UUFDbEQsSUFBSXNFLG9CQUFvQjtZQUNwQkEsbUJBQW1CbEUsV0FBVyxHQUFHLGlCQUE2QyxPQUE1QixJQUFJRixPQUFPQyxjQUFjO1FBQy9FO0lBQ0osRUFBRSxPQUFPUixPQUFPO1FBQ1pELFFBQVFDLEtBQUssQ0FBQyw4QkFBOEJBO1FBQzVDSCxvQkFBb0I7SUFDeEI7QUFDSjtBQVdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvY29udmVydGVyL2NvbnZlcnRlci5qcz9mM2JkIl0sInNvdXJjZXNDb250ZW50IjpbImxldCBleGNoYW5nZVJhdGVzID0ge307XG5sZXQgbGFzdFVwZGF0ZVRpbWUgPSBudWxsO1xuXG5mdW5jdGlvbiBkaXNwbGF5RXJyb3JNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIGFsZXJ0KG1lc3NhZ2UpO1xufVxuXG5mdW5jdGlvbiBkaXNwbGF5TGFzdFVwZGF0ZVRpbWUoKSB7XG4gICAgY29uc3QgdXBkYXRlRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjbGFzdFVwZGF0ZVRpbWVcIik7XG5cbiAgICBpZiAobGFzdFVwZGF0ZVRpbWUpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkVGltZSA9IG5ldyBEYXRlKGxhc3RVcGRhdGVUaW1lKS50b0xvY2FsZVN0cmluZygpO1xuICAgICAgICB1cGRhdGVFbGVtZW50LnRleHRDb250ZW50ID0gYExhc3QgVXBkYXRlZDogJHtmb3JtYXR0ZWRUaW1lfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlRWxlbWVudC50ZXh0Q29udGVudCA9IFwiRGF0YSBoYXMgbm90IGJlZW4gdXBkYXRlZCB5ZXQuXCI7XG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiB1cGRhdGVFeGNoYW5nZVJhdGVzKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgICAgICAgICBcImh0dHBzOi8vYXBpLmV4Y2hhbmdlcmF0ZS1hcGkuY29tL3Y0L2xhdGVzdC9VU0RcIiAvLyBGZXRjaCBFeGNoYW5nZSBSYXRlc1xuICAgICAgICApO1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgIGlmIChkYXRhLnJhdGVzKSB7XG4gICAgICAgICAgICAvLyBGaWx0ZXIgZGVzaXJlZCBjdXJyZW5jaWVzIGZyb20gdGhlIEFQSSByZXNwb25zZVxuICAgICAgICAgICAgY29uc3QgZGVzaXJlZEN1cnJlbmNpZXMgPSBbXG4gICAgICAgICAgICAgICAgXCJVU0RcIixcbiAgICAgICAgICAgICAgICBcIktSV1wiLFxuICAgICAgICAgICAgICAgIFwiQVVEXCIsXG4gICAgICAgICAgICAgICAgXCJCUkxcIixcbiAgICAgICAgICAgICAgICBcIkNBRFwiLFxuICAgICAgICAgICAgICAgIFwiQ05ZXCIsXG4gICAgICAgICAgICAgICAgXCJFVVJcIixcbiAgICAgICAgICAgICAgICBcIkdCUFwiLFxuICAgICAgICAgICAgICAgIFwiSlBZXCIsXG4gICAgICAgICAgICAgICAgXCJNWE5cIixcbiAgICAgICAgICAgICAgICBcIlBIUFwiLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkUmF0ZXMgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoZGF0YS5yYXRlcykuZmlsdGVyKChbY3VycmVuY3ldKSA9PlxuICAgICAgICAgICAgICAgICAgICBkZXNpcmVkQ3VycmVuY2llcy5pbmNsdWRlcyhjdXJyZW5jeSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBleGNoYW5nZVJhdGVzID0gZmlsdGVyZWRSYXRlcztcbiAgICAgICAgICAgIGxhc3RVcGRhdGVUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRXhjaGFuZ2UgUmF0ZXMgVXBkYXRlZDpcIiwgZXhjaGFuZ2VSYXRlcyk7XG4gICAgICAgICAgICBkaXNwbGF5TGFzdFVwZGF0ZVRpbWUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gdXBkYXRlIEV4Y2hhbmdlIFJhdGVzOlwiLCBkYXRhKTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB1cGRhdGluZyBFeGNoYW5nZSBSYXRlczpcIiwgZXJyb3IpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbWFwQ291bnRyeUNvZGUoYXBpQ291bnRyeUNvZGUpIHtcbiAgICBjb25zdCBjb2RlTWFwcGluZyA9IHtcbiAgICAgICAgVVM6IFwidXNkXCIsXG4gICAgICAgIEtSOiBcImtyd1wiLFxuICAgICAgICBBVTogXCJhdWRcIixcbiAgICAgICAgQlI6IFwiYnJsXCIsXG4gICAgICAgIENBOiBcImNhZFwiLFxuICAgICAgICBDTjogXCJjbnlcIixcbiAgICAgICAgRVU6IFwiZXVyXCIsXG4gICAgICAgIEdCOiBcImdicFwiLFxuICAgICAgICBKUDogXCJqcHlcIixcbiAgICAgICAgTVg6IFwibXhuXCIsXG4gICAgICAgIFBIOiBcInBocFwiLFxuICAgIH07XG5cbiAgICByZXR1cm4gY29kZU1hcHBpbmdbYXBpQ291bnRyeUNvZGVdIHx8IGFwaUNvdW50cnlDb2RlO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRVc2VyQ291bnRyeSgpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiaHR0cHM6Ly9pcGFwaS5jby9qc29uL1wiKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICBpZiAoZGF0YS5jb3VudHJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gbWFwQ291bnRyeUNvZGUoXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNmcm9tQ3VycmVuY3lcIikudmFsdWVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGdldCB1c2VyIGNvdW50cnk6XCIsIGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZ2V0dGluZyB1c2VyIGNvdW50cnk6XCIsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIGNvbnN0IGRlZmF1bHRDdXJyZW5jeSA9IFwiXCI7XG5cbiAgICBpZiAoZGVmYXVsdEN1cnJlbmN5KSB7XG4gICAgICAgIGNvbnN0IGZyb21DdXJyZW5jeUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2Zyb21DdXJyZW5jeVwiKTtcbiAgICAgICAgY29uc3QgdG9DdXJyZW5jeUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3RvQ3VycmVuY3lcIik7XG5cbiAgICAgICAgZnJvbUN1cnJlbmN5RWxlbWVudC52YWx1ZSA9IGRlZmF1bHRDdXJyZW5jeTtcbiAgICAgICAgdG9DdXJyZW5jeUVsZW1lbnQudmFsdWUgPSBcInVzZFwiO1xuXG4gICAgICAgIGF3YWl0IHVwZGF0ZUV4Y2hhbmdlUmF0ZXMoKTtcbiAgICAgICAgZGlzcGxheUxhc3RVcGRhdGVUaW1lKCk7XG5cbiAgICAgICAgc2V0SW50ZXJ2YWwodXBkYXRlRXhjaGFuZ2VSYXRlcywgMzYwMDAwMCk7IC8vIFVwZGF0ZSBFeGNoYW5nZSBSYXRlcyBldmVyeSAxIGhyXG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiRmFpbGVkIHRvIGdldCB1c2VyIGNvdW50cnkgY29kZS4gUGxlYXNlIHNldCBkZWZhdWx0IGN1cnJlbmN5IG1hbnVhbGx5LlwiXG4gICAgICAgICk7XG4gICAgfVxufVxuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBpbml0aWFsaXplKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlRXhjaGFuZ2VSYXRlKGZyb21DdXJyZW5jeSwgdG9DdXJyZW5jeSkge1xuICAgIGlmIChcbiAgICAgICAgZXhjaGFuZ2VSYXRlcyAmJlxuICAgICAgICBleGNoYW5nZVJhdGVzW2Zyb21DdXJyZW5jeV0gJiZcbiAgICAgICAgZXhjaGFuZ2VSYXRlc1t0b0N1cnJlbmN5XVxuICAgICkge1xuICAgICAgICByZXR1cm4gZXhjaGFuZ2VSYXRlc1t0b0N1cnJlbmN5XSAvIGV4Y2hhbmdlUmF0ZXNbZnJvbUN1cnJlbmN5XTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvbnZlcnRDdXJyZW5jeShmcm9tQ3VycmVuY3ksIHRvQ3VycmVuY3ksIGFtb3VudCkge1xuICAgIGNvbnN0IGZyb21DdXJyZW5jeUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2Zyb21DdXJyZW5jeVwiKTtcbiAgICBjb25zdCB0b0N1cnJlbmN5RWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjdG9DdXJyZW5jeVwiKTtcbiAgICBjb25zdCBhbW91bnRFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNhbW91bnRcIik7XG5cbiAgICBpZiAoIWZyb21DdXJyZW5jeUVsZW1lbnQgfHwgIXRvQ3VycmVuY3lFbGVtZW50IHx8ICFhbW91bnRFbGVtZW50KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlJlcXVpcmVkIGVsZW1lbnRzIG5vdCBmb3VuZC4gUGxlYXNlIGNoZWNrIHlvdXIgSFRNTCBzdHJ1Y3R1cmUuXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZyb21DdXJyZW5jeSA9IFN0cmluZyhmcm9tQ3VycmVuY3kpLnRvVXBwZXJDYXNlKCk7XG4gICAgdG9DdXJyZW5jeSA9IFN0cmluZyh0b0N1cnJlbmN5KS50b1VwcGVyQ2FzZSgpO1xuICAgIGFtb3VudCA9IHBhcnNlRmxvYXQoYW1vdW50KTtcblxuICAgIGlmICghYW1vdW50KSB7XG4gICAgICAgIC8vIE5vIGFtb3VudFxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGV4Y2hhbmdlUmF0ZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgYXdhaXQgdXBkYXRlRXhjaGFuZ2VSYXRlcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXhjaGFuZ2VSYXRlID0gY2FsY3VsYXRlRXhjaGFuZ2VSYXRlKGZyb21DdXJyZW5jeSwgdG9DdXJyZW5jeSk7XG4gICAgICAgIGlmIChleGNoYW5nZVJhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IChhbW91bnQgKiBleGNoYW5nZVJhdGUpLnRvRml4ZWQoMik7XG5cbiAgICAgICAgY29uc3QgZm9ybWF0dGVkRnJvbUN1cnJlbmN5ID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KFwiZW4tVVNcIiwge1xuICAgICAgICAgICAgc3R5bGU6IFwiY3VycmVuY3lcIixcbiAgICAgICAgICAgIGN1cnJlbmN5OiBmcm9tQ3VycmVuY3ksXG4gICAgICAgICAgICBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IDIsXG4gICAgICAgICAgICBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IDIsXG4gICAgICAgICAgICBjdXJyZW5jeURpc3BsYXk6IFwic3ltYm9sXCIsXG4gICAgICAgIH0pLmZvcm1hdChhbW91bnQudG9GaXhlZCgyKSk7XG5cbiAgICAgICAgY29uc3QgZm9ybWF0dGVkVG9DdXJyZW5jeSA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChcImVuLVVTXCIsIHtcbiAgICAgICAgICAgIHN0eWxlOiBcImN1cnJlbmN5XCIsXG4gICAgICAgICAgICBjdXJyZW5jeTogdG9DdXJyZW5jeSxcbiAgICAgICAgICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogMixcbiAgICAgICAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogMixcbiAgICAgICAgICAgIGN1cnJlbmN5RGlzcGxheTogXCJzeW1ib2xcIixcbiAgICAgICAgfSkuZm9ybWF0KHJlc3VsdCk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0RWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjcmVzdWx0XCIpO1xuXG4gICAgICAgIGlmICghcmVzdWx0RWxlbWVudCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIlJlc3VsdCBlbGVtZW50IG5vdCBmb3VuZC4gUGxlYXNlIGNoZWNrIHlvdXIgSFRNTCBzdHJ1Y3R1cmUuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHRFbGVtZW50LmlubmVySFRNTCA9IGAke2Zvcm1hdHRlZEZyb21DdXJyZW5jeX0gPSAke2Zvcm1hdHRlZFRvQ3VycmVuY3l9YDtcblxuICAgICAgICBjb25zdCBsYXN0VXBkYXRlZEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2xhc3RVcGRhdGVkXCIpO1xuICAgICAgICBpZiAobGFzdFVwZGF0ZWRFbGVtZW50KSB7XG4gICAgICAgICAgICBsYXN0VXBkYXRlZEVsZW1lbnQudGV4dENvbnRlbnQgPSBgTGFzdCBVcGRhdGVkOiAke25ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKX1gO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNvbnZlcnRpbmcgY3VycmVuY3k6XCIsIGVycm9yKTtcbiAgICAgICAgZGlzcGxheUVycm9yTWVzc2FnZShcIkVycm9yIGNvbnZlcnRpbmcgY3VycmVuY3kuXCIpO1xuICAgIH1cbn1cblxuZXhwb3J0IHtcbiAgICBleGNoYW5nZVJhdGVzLFxuICAgIGxhc3RVcGRhdGVUaW1lLFxuICAgIGRpc3BsYXlFcnJvck1lc3NhZ2UsXG4gICAgdXBkYXRlRXhjaGFuZ2VSYXRlcyxcbiAgICBtYXBDb3VudHJ5Q29kZSxcbiAgICBnZXRVc2VyQ291bnRyeSxcbiAgICBjYWxjdWxhdGVFeGNoYW5nZVJhdGUsXG4gICAgY29udmVydEN1cnJlbmN5LFxufTtcbiJdLCJuYW1lcyI6WyJleGNoYW5nZVJhdGVzIiwibGFzdFVwZGF0ZVRpbWUiLCJkaXNwbGF5RXJyb3JNZXNzYWdlIiwibWVzc2FnZSIsImNvbnNvbGUiLCJlcnJvciIsImFsZXJ0IiwiZGlzcGxheUxhc3RVcGRhdGVUaW1lIiwidXBkYXRlRWxlbWVudCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImZvcm1hdHRlZFRpbWUiLCJEYXRlIiwidG9Mb2NhbGVTdHJpbmciLCJ0ZXh0Q29udGVudCIsInVwZGF0ZUV4Y2hhbmdlUmF0ZXMiLCJyZXNwb25zZSIsImZldGNoIiwiZGF0YSIsImpzb24iLCJyYXRlcyIsImRlc2lyZWRDdXJyZW5jaWVzIiwiZmlsdGVyZWRSYXRlcyIsIk9iamVjdCIsImZyb21FbnRyaWVzIiwiZW50cmllcyIsImZpbHRlciIsImN1cnJlbmN5IiwiaW5jbHVkZXMiLCJub3ciLCJsb2ciLCJtYXBDb3VudHJ5Q29kZSIsImFwaUNvdW50cnlDb2RlIiwiY29kZU1hcHBpbmciLCJVUyIsIktSIiwiQVUiLCJCUiIsIkNBIiwiQ04iLCJFVSIsIkdCIiwiSlAiLCJNWCIsIlBIIiwiZ2V0VXNlckNvdW50cnkiLCJjb3VudHJ5IiwidmFsdWUiLCJpbml0aWFsaXplIiwiZGVmYXVsdEN1cnJlbmN5IiwiZnJvbUN1cnJlbmN5RWxlbWVudCIsInRvQ3VycmVuY3lFbGVtZW50Iiwic2V0SW50ZXJ2YWwiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwiY2FsY3VsYXRlRXhjaGFuZ2VSYXRlIiwiZnJvbUN1cnJlbmN5IiwidG9DdXJyZW5jeSIsImNvbnZlcnRDdXJyZW5jeSIsImFtb3VudCIsImFtb3VudEVsZW1lbnQiLCJTdHJpbmciLCJ0b1VwcGVyQ2FzZSIsInBhcnNlRmxvYXQiLCJrZXlzIiwibGVuZ3RoIiwiZXhjaGFuZ2VSYXRlIiwicmVzdWx0IiwidG9GaXhlZCIsImZvcm1hdHRlZEZyb21DdXJyZW5jeSIsIkludGwiLCJOdW1iZXJGb3JtYXQiLCJzdHlsZSIsIm1pbmltdW1GcmFjdGlvbkRpZ2l0cyIsIm1heGltdW1GcmFjdGlvbkRpZ2l0cyIsImN1cnJlbmN5RGlzcGxheSIsImZvcm1hdCIsImZvcm1hdHRlZFRvQ3VycmVuY3kiLCJyZXN1bHRFbGVtZW50IiwiaW5uZXJIVE1MIiwibGFzdFVwZGF0ZWRFbGVtZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/converter/converter.js\n"));

/***/ })

});